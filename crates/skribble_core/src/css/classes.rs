use std::fmt::Write;
use std::ops::Deref;
use std::ops::DerefMut;

use indent_write::fmt::IndentWriter;
use indexmap::indexset;
use indexmap::IndexMap;
use indexmap::IndexSet;
use serde::Deserialize;
use serde::Serialize;

use super::Class;
use crate::indent_writer;
use crate::AnyEmptyResult;
use crate::ClassFactory;
use crate::RunnerConfig;
use crate::ToSkribbleCss;

#[derive(Clone, Debug, Default, Deserialize, Serialize, PartialEq, Eq)]
pub struct Classes(IndexSet<Class>);

impl Classes {
  pub fn insert_factory(&mut self, class_factory: ClassFactory) -> bool {
    self.insert_optional(class_factory.into_class())
  }

  pub fn insert_factories(&mut self, class_factories: Vec<ClassFactory>) {
    for class_factory in class_factories {
      self.insert_factory(class_factory);
    }
  }

  pub fn insert_optional(&mut self, class: Option<Class>) -> bool {
    match class {
      Some(class) => self.insert(class),
      _ => false,
    }
  }

  pub fn extend_optional(&mut self, classes: Option<Classes>) {
    if let Some(classes) = classes {
      self.extend(classes);
    }
  }

  pub fn merge(&mut self, other: impl Into<Self>) {
    self.extend(other.into().0);
  }

  pub fn sort_by_class(&mut self) {
    self.sort_by(|a, b| a.cmp(b));
  }

  fn write_keyframes(&self, writer: &mut dyn Write, config: &RunnerConfig) -> AnyEmptyResult {
    let mut set = indexset! {};

    for class in self.iter() {
      let Some(keyframe) = class.get_keyframe() else {
        continue;
      };

      if set.get(keyframe).is_some() {
        continue;
      }

      set.insert(keyframe);

      let keyframe = config
        .keyframes
        .get(keyframe)
        .ok_or_else(|| format!("Keyframe {} not found", keyframe))?;

      keyframe.write_skribble_css(writer, config)?;
    }

    Ok(())
  }

  fn write_css_variables(&self, writer: &mut dyn Write, config: &RunnerConfig) -> AnyEmptyResult {
    let mut css_variables = indexset! {};

    for class in self.iter() {
      class.collect_css_variables(&mut css_variables);
    }

    for value in css_variables
      .iter()
      .map(|name| config.css_variables.get(name))
    {
      let Some( css_variable) = value else {
        continue;
      };

      css_variable.write_property_rule(writer, config)?;
    }

    // TODO think about how to handle the nested css variables in media queries

    Ok(())
  }

  fn write_layers_header(&self, writer: &mut dyn Write, config: &RunnerConfig) -> AnyEmptyResult {
    let length = config.layers.len();

    if length == 0 {
      return Ok(());
    }

    write!(writer, "@layer ")?;

    for (index, layer) in config.layers.iter().enumerate() {
      write!(writer, "{layer}")?;

      if index + 1 < length {
        write!(writer, ", ")?;
      }
    }

    writeln!(writer, ";")?;

    Ok(())
  }

  fn write_layer_css(
    &self,
    writer: &mut dyn Write,
    config: &RunnerConfig,
    layer: Option<&String>,
  ) -> AnyEmptyResult {
    let mut media_query_classes = IndexMap::<Option<String>, Vec<&Class>>::new();

    for class in self.iter().filter(|class| class.get_layer() == layer) {
      let key = class.join_media_query(config);

      match media_query_classes.get_mut(&key) {
        Some(existing) => {
          existing.push(class);
        }
        None => {
          media_query_classes.insert(key, vec![class]);
        }
      }
    }

    for (media_query, classes) in media_query_classes.iter() {
      if let Some(media_query) = media_query {
        writeln!(writer, "@media {media_query} {{")?;
        let mut child_writer = indent_writer();
        self.write_media_query_css(&mut child_writer, config, classes)?;
        write!(writer, "{}", child_writer.get_ref())?;
        writeln!(writer, "}}")?;
      } else {
        self.write_media_query_css(writer, config, classes)?;
      }
    }

    Ok(())
  }

  fn write_media_query_css(
    &self,
    writer: &mut dyn Write,
    config: &RunnerConfig,
    classes: &Vec<&Class>,
  ) -> AnyEmptyResult {
    for class in classes {
      class.write_skribble_css(writer, config)?;
    }
    Ok(())
  }
}

impl ToSkribbleCss for Classes {
  fn write_skribble_css(&self, writer: &mut dyn Write, config: &RunnerConfig) -> AnyEmptyResult {
    let options = config.options();

    writeln!(writer, "/* Generated by Skribble */")?;
    writeln!(writer, "@charset \"{}\";", options.charset)?;
    self.write_layers_header(writer, config)?;
    self.write_keyframes(writer, config)?;
    self.write_css_variables(writer, config)?;

    for layer in config.layers.iter() {
      writeln!(writer, "@layer {layer} {{")?;
      let mut indented = IndentWriter::new("  ", String::new());

      self.write_layer_css(
        &mut indented,
        config,
        if layer == &options.default_layer {
          None
        } else {
          Some(layer)
        },
      )?;
      write!(writer, "{}", indented.get_ref())?;
      writeln!(writer, "}}")?;
    }

    Ok(())
  }
}

impl From<Vec<Class>> for Classes {
  fn from(classes: Vec<Class>) -> Self {
    Self(classes.into_iter().collect())
  }
}

impl From<IndexSet<Class>> for Classes {
  fn from(classes: IndexSet<Class>) -> Self {
    Self(classes.into_iter().collect())
  }
}

impl IntoIterator for Classes {
  type IntoIter = <IndexSet<Class> as IntoIterator>::IntoIter;
  type Item = Class;

  fn into_iter(self) -> Self::IntoIter {
    self.0.into_iter()
  }
}

impl FromIterator<Class> for Classes {
  fn from_iter<T: IntoIterator<Item = Class>>(iter: T) -> Self {
    Self(iter.into_iter().collect())
  }
}

impl Deref for Classes {
  type Target = IndexSet<Class>;

  fn deref(&self) -> &Self::Target {
    &self.0
  }
}

impl DerefMut for Classes {
  fn deref_mut(&mut self) -> &mut Self::Target {
    &mut self.0
  }
}
